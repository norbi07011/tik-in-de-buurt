import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import User, { IUser } from '../models/User';
import AuthService from '../services/authService';
import { logger } from '../utils/logger';

// Extend Express Request interface to include user
declare global {
  namespace Express {
    interface Request {
      user?: IUser & {
        userId: string;
        username: string;
        email: string;
        role: string;
      };
    }
  }
}

interface JwtPayload {
  userId: string;
  iat: number;
  exp: number;
}

export const authenticateToken = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
      res.status(401).json({ 
        success: false, 
        error: 'Access token required',
        code: 'TOKEN_MISSING' 
      });
      return;
    }

    // Use AuthService for verification
    const decoded = AuthService.verifyToken(token);
    
    // Fetch user from database
    const user = await User.findById(decoded.id);
    if (!user) {
      res.status(401).json({ 
        success: false, 
        error: 'Invalid token - user not found',
        code: 'USER_NOT_FOUND' 
      });
      return;
    }

    // Check if user is active (add this field to user model later if needed)
    // if (user.isBlocked) {
    //   res.status(401).json({ 
    //     success: false, 
    //     error: 'Account has been blocked',
    //     code: 'ACCOUNT_BLOCKED' 
    //   });
    //   return;
    // }

    // Set user with additional properties for compatibility
    req.user = {
      ...user.toObject(),
      userId: user._id.toString(),
      username: user.name || user.email,
      email: user.email,
      role: user.userType || 'user'
    } as any;
    next();
  } catch (error: any) {
    if (error.message === 'Invalid or expired access token') {
      res.status(401).json({ 
        success: false, 
        error: 'Token expired or invalid',
        code: 'TOKEN_EXPIRED' 
      });
      return;
    }
    
    console.error('Auth middleware error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Authentication failed',
      code: 'AUTH_ERROR' 
    });
  }
};

export const optionalAuth = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
      next();
      return;
    }

    // Use AuthService for verification
    const decoded = AuthService.verifyToken(token);
    const user = await User.findById(decoded.id);
    
    if (user) {
      req.user = {
        ...user.toObject(),
        userId: user._id.toString(),
        username: user.name || user.email,
        email: user.email,
        role: user.userType || 'user'
      } as any;
    }
    
    next();
  } catch (error) {
    // For optional auth, we just continue without user
    next();
  }
};

// Generate JWT tokens (deprecated - use TokenService instead)
export const generateToken = (userId: string): string => {
  console.warn('⚠️  generateToken is deprecated, use TokenService.generateTokens instead');
  
  return jwt.sign(
    { userId },
    process.env.JWT_SECRET || 'your-super-secret-jwt-key',
    { expiresIn: '7d' } as jwt.SignOptions
  );
};

// New middleware for refresh token validation
export const validateRefreshToken = (req: Request, res: Response, next: NextFunction): void => {
  try {
    const { refreshToken } = req.body;
    
    if (!refreshToken) {
      res.status(401).json({ 
        success: false, 
        error: 'Refresh token required',
        code: 'REFRESH_TOKEN_MISSING' 
      });
      return;
    }

    const decoded = AuthService.verifyToken(refreshToken);
    req.body.userId = decoded.id;
    next();
  } catch (error) {
    res.status(401).json({ 
      success: false, 
      error: 'Invalid or expired refresh token',
      code: 'INVALID_REFRESH_TOKEN' 
    });
  }
};

// Additional middleware for Maps & Geolocation
export const requireRole = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.user) {
      res.status(401).json({
        success: false,
        error: 'Authentication required'
      });
      return;
    }

    if (!roles.includes(req.user.role)) {
      logger.warn(`Access denied for user ${req.user.userId} with role ${req.user.role}`);
      res.status(403).json({
        success: false,
        error: 'Insufficient permissions'
      });
      return;
    }

    next();
  };
};

export const rateLimiter = (maxRequests: number, windowMs: number) => {
  const requests = new Map<string, { count: number; resetTime: number }>();

  return (req: Request, res: Response, next: NextFunction) => {
    const identifier = req.ip || req.headers['x-forwarded-for'] || 'unknown';
    const now = Date.now();
    
    const userRequests = requests.get(identifier as string);
    
    if (!userRequests || now > userRequests.resetTime) {
      // Reset or initialize counter
      requests.set(identifier as string, {
        count: 1,
        resetTime: now + windowMs
      });
      return next();
    }
    
    if (userRequests.count >= maxRequests) {
      logger.warn(`Rate limit exceeded for ${identifier}`);
      return res.status(429).json({
        success: false,
        error: 'Rate limit exceeded',
        retryAfter: Math.ceil((userRequests.resetTime - now) / 1000)
      });
    }
    
    userRequests.count++;
    next();
  };
};

export const validateLocationData = (req: Request, res: Response, next: NextFunction): void => {
  const { latitude, longitude } = req.body;

  if (latitude === undefined || longitude === undefined) {
    return res.status(400).json({
      success: false,
      error: 'Latitude and longitude are required'
    });
  }

  const lat = parseFloat(latitude);
  const lng = parseFloat(longitude);

  if (isNaN(lat) || isNaN(lng)) {
    return res.status(400).json({
      success: false,
      error: 'Latitude and longitude must be valid numbers'
    });
  }

  if (lat < -90 || lat > 90) {
    return res.status(400).json({
      success: false,
      error: 'Latitude must be between -90 and 90 degrees'
    });
  }

  if (lng < -180 || lng > 180) {
    return res.status(400).json({
      success: false,
      error: 'Longitude must be between -180 and 180 degrees'
    });
  }

  // Normalize the values
  req.body.latitude = lat;
  req.body.longitude = lng;

  next();
};

export const validateGeofenceData = (req: Request, res: Response, next: NextFunction): void => {
  const { name, geometry, type, triggers } = req.body;

  if (!name || typeof name !== 'string' || name.trim().length === 0) {
    return res.status(400).json({
      success: false,
      error: 'Name is required and must be a non-empty string'
    });
  }

  if (!geometry || typeof geometry !== 'object') {
    return res.status(400).json({
      success: false,
      error: 'Geometry is required and must be an object'
    });
  }

  if (!['circular', 'polygon'].includes(type)) {
    return res.status(400).json({
      success: false,
      error: 'Type must be either "circular" or "polygon"'
    });
  }

  if (!triggers || !Array.isArray(triggers) || triggers.length === 0) {
    return res.status(400).json({
      success: false,
      error: 'Triggers must be a non-empty array'
    });
  }

  const validTriggers = ['enter', 'exit', 'dwell'];
  const invalidTriggers = triggers.filter(trigger => !validTriggers.includes(trigger));
  
  if (invalidTriggers.length > 0) {
    return res.status(400).json({
      success: false,
      error: `Invalid triggers: ${invalidTriggers.join(', ')}. Valid triggers are: ${validTriggers.join(', ')}`
    });
  }

  // Validate geometry based on type
  if (type === 'circular') {
    const { center, radius } = geometry;
    
    if (!center || typeof center !== 'object' || 
        typeof center.latitude !== 'number' || typeof center.longitude !== 'number') {
      return res.status(400).json({
        success: false,
        error: 'Circular geofence requires geometry.center with latitude and longitude'
      });
    }
    
    if (typeof radius !== 'number' || radius <= 0) {
      return res.status(400).json({
        success: false,
        error: 'Circular geofence requires geometry.radius as a positive number'
      });
    }
  } else if (type === 'polygon') {
    const { coordinates } = geometry;
    
    if (!coordinates || !Array.isArray(coordinates) || coordinates.length < 3) {
      return res.status(400).json({
        success: false,
        error: 'Polygon geofence requires geometry.coordinates with at least 3 points'
      });
    }
    
    const invalidCoordinates = coordinates.some(coord => 
      typeof coord.latitude !== 'number' || typeof coord.longitude !== 'number'
    );
    
    if (invalidCoordinates) {
      return res.status(400).json({
        success: false,
        error: 'All polygon coordinates must have valid latitude and longitude numbers'
      });
    }
  }

  next();
};

export const validateRouteData = (req: Request, res: Response, next: NextFunction): void => {
  const { waypoints, options } = req.body;

  if (!waypoints || !Array.isArray(waypoints) || waypoints.length < 2) {
    return res.status(400).json({
      success: false,
      error: 'Waypoints must be an array with at least 2 waypoints'
    });
  }

  // Validate each waypoint
  for (let i = 0; i < waypoints.length; i++) {
    const waypoint = waypoints[i];
    
    if (!waypoint || typeof waypoint !== 'object') {
      return res.status(400).json({
        success: false,
        error: `Waypoint ${i + 1} must be an object`
      });
    }
    
    if (typeof waypoint.latitude !== 'number' || typeof waypoint.longitude !== 'number') {
      return res.status(400).json({
        success: false,
        error: `Waypoint ${i + 1} must have valid latitude and longitude numbers`
      });
    }
    
    if (waypoint.latitude < -90 || waypoint.latitude > 90) {
      return res.status(400).json({
        success: false,
        error: `Waypoint ${i + 1} latitude must be between -90 and 90 degrees`
      });
    }
    
    if (waypoint.longitude < -180 || waypoint.longitude > 180) {
      return res.status(400).json({
        success: false,
        error: `Waypoint ${i + 1} longitude must be between -180 and 180 degrees`
      });
    }
  }

  if (!options || typeof options !== 'object') {
    return res.status(400).json({
      success: false,
      error: 'Options object is required'
    });
  }

  if (!options.mode || typeof options.mode !== 'string') {
    return res.status(400).json({
      success: false,
      error: 'Options.mode is required and must be a string'
    });
  }

  const validModes = ['driving', 'walking', 'bicycling', 'transit'];
  if (!validModes.includes(options.mode)) {
    return res.status(400).json({
      success: false,
      error: `Invalid mode: ${options.mode}. Valid modes are: ${validModes.join(', ')}`
    });
  }

  next();
};