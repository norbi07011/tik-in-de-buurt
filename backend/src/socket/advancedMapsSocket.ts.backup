import { Server as SocketIOServer, Socket } from 'socket.io';
import { Server as HTTPServer } from 'http';
import { logger } from '../utils/logger';
import AdvancedLocationTrackingService from '../services/advancedLocationTrackingService';
import GeofencingService from '../services/geofencingService';
import AdvancedNavigationService from '../services/advancedNavigationService';
import AuthService from '../services/authService';

export interface AuthenticatedSocket extends Socket {
  userId: string;
  username: string;
  joinedRooms: Set<string>;
}

export class AdvancedMapsSocketHandler {
  private io: SocketIOServer;
  private locationTrackingService: AdvancedLocationTrackingService;
  private geofencingService: GeofencingService;
  private navigationService: AdvancedNavigationService;
  private connectedUsers: Map<string, AuthenticatedSocket>;
  private locationTrackers: Map<string, NodeJS.Timeout>;
  private navigationSessions: Map<string, { socket: AuthenticatedSocket, sessionId: string }>;

  constructor(server: HTTPServer) {
    this.io = new SocketIOServer(server, {
      cors: {
        origin: [
          'http://localhost:3000',
          'http://localhost:5173',
          'https://tik-in-de-buurt.netlify.app',
          'https://www.tik-in-de-buurt.com'
        ],
        methods: ['GET', 'POST'],
        credentials: true
      },
      transports: ['websocket', 'polling']
    });

    this.locationTrackingService = new AdvancedLocationTrackingService();
    this.geofencingService = new GeofencingService();
    this.navigationService = new AdvancedNavigationService();
    this.connectedUsers = new Map();
    this.locationTrackers = new Map();
    this.navigationSessions = new Map();

    this.setupMiddleware();
    this.setupEventHandlers();
    
    logger.info('📍 Advanced Maps Socket.IO handler initialized');
  }

  private setupMiddleware(): void {
    // Authentication middleware
    this.io.use(async (socket, next) => {
      try {
        const token = socket.handshake.auth.token || socket.handshake.headers.authorization?.split(' ')[1];
        
        if (!token) {
          logger.warn('Socket connection rejected: No authentication token');
          return next(new Error('Authentication required'));
        }

        const decoded = AuthService.verifyToken(token);
        (socket as AuthenticatedSocket).userId = decoded.id;
        (socket as AuthenticatedSocket).username = decoded.name || 'Unknown';
        (socket as AuthenticatedSocket).joinedRooms = new Set();
        
        logger.info(`Socket authenticated: ${decoded.id} (${decoded.name || 'Unknown'})`);
        next();
      } catch (error) {
        logger.error('Socket authentication failed:', error);
        next(new Error('Invalid authentication token'));
      }
    });
  }

  private setupEventHandlers(): void {
    this.io.on('connection', (socket) => {
      const authSocket = socket as AuthenticatedSocket;
      logger.info(`🔗 User connected: ${authSocket.userId} (${authSocket.username})`);
      
      // Store connected user
      this.connectedUsers.set(authSocket.userId, authSocket);
      
      // Join user to their personal room
      socket.join(`user:${socket.userId}`);
      socket.joinedRooms.add(`user:${socket.userId}`);

      // Setup location tracking events
      this.setupLocationTrackingEvents(socket);
      
      // Setup geofencing events
      this.setupGeofencingEvents(socket);
      
      // Setup navigation events
      this.setupNavigationEvents(socket);
      
      // Setup general events
      this.setupGeneralEvents(socket);

      // Handle disconnection
      socket.on('disconnect', () => {
        this.handleDisconnection(socket);
      });
    });
  }

  private setupLocationTrackingEvents(socket: AuthenticatedSocket): void {
    // Start real-time location tracking
    socket.on('location:start-tracking', async (data) => {
      try {
        const { trackingMode = 'balanced', shareWith = [] } = data;
        
        const result = await this.locationTrackingService.startLocationTracking(
          socket.userId!,
          trackingMode
        );

        if (result.success) {
          socket.emit('location:tracking-started', {
            success: true,
            trackingId: result.trackingId,
            mode: trackingMode
          });

          // Join location sharing rooms if specified
          shareWith.forEach((userId: string) => {
            socket.join(`location-share:${userId}`);
            socket.joinedRooms.add(`location-share:${userId}`);
          });

          logger.info(`Location tracking started for user ${socket.userId}`);
        } else {
          socket.emit('location:tracking-error', {
            success: false,
            error: 'Failed to start location tracking'
          });
        }
      } catch (error) {
        logger.error('Error starting location tracking:', error);
        socket.emit('location:tracking-error', {
          success: false,
          error: 'Internal server error'
        });
      }
    });

    // Receive location updates
    socket.on('location:update', async (locationData) => {
      try {
        const { latitude, longitude, accuracy, altitude, heading, speed } = locationData;
        
        const success = await this.locationTrackingService.updateLocation(
          socket.userId!,
          { latitude, longitude, accuracy, altitude, heading, speed }
        );

        if (success) {
          // Broadcast to location sharing rooms
          socket.broadcast.to(`location-share:${socket.userId}`).emit('location:user-moved', {
            userId: socket.userId,
            username: socket.username,
            location: { latitude, longitude, accuracy, altitude, heading, speed },
            timestamp: new Date()
          });

          // Process geofencing
          const geofenceEvents = await this.geofencingService.processLocationUpdate(
            socket.userId!,
            { latitude, longitude, accuracy }
          );

          // Emit geofence events
          geofenceEvents.forEach(event => {
            socket.emit('geofence:event', event);
            
            // Notify other relevant users
            this.io.to(`geofence:${event.geofenceId}`).emit('geofence:user-event', {
              userId: socket.userId,
              username: socket.username,
              event
            });
          });

          // Update active navigation if exists
          const navigationSession = Array.from(this.navigationSessions.entries())
            .find(([_, session]) => session.socket.userId === socket.userId);

          if (navigationSession) {
            const [sessionId, session] = navigationSession;
            const navUpdate = await this.navigationService.updateNavigation(
              session.sessionId,
              { latitude, longitude, accuracy }
            );

            if (navUpdate.success) {
              socket.emit('navigation:instruction', {
                instruction: navUpdate.instruction,
                nextInstructions: navUpdate.nextInstructions,
                needsReroute: navUpdate.needsReroute,
                distanceToNext: navUpdate.distanceToNext,
                estimatedArrival: navUpdate.estimatedArrival
              });
            }
          }
        }
      } catch (error) {
        logger.error('Error processing location update:', error);
        socket.emit('location:update-error', {
          success: false,
          error: 'Failed to process location update'
        });
      }
    });

    // Stop location tracking
    socket.on('location:stop-tracking', async () => {
      try {
        const success = await this.locationTrackingService.stopLocationTracking(socket.userId!);
        
        socket.emit('location:tracking-stopped', { success });
        
        // Leave location sharing rooms
        socket.joinedRooms.forEach(room => {
          if (room.startsWith('location-share:')) {
            socket.leave(room);
          }
        });

        logger.info(`Location tracking stopped for user ${socket.userId}`);
      } catch (error) {
        logger.error('Error stopping location tracking:', error);
        socket.emit('location:tracking-error', {
          success: false,
          error: 'Failed to stop location tracking'
        });
      }
    });

    // Join location sharing session
    socket.on('location:join-sharing', async (data) => {
      try {
        const { sessionId, targetUserId } = data;
        
        // Verify sharing session exists and user has permission
        const sharedLocations = await this.locationTrackingService.getSharedLocations(socket.userId!);
        const validSession = sharedLocations.some(session => 
          session.sessionId === sessionId && session.sharedWith.includes(socket.userId!)
        );

        if (validSession) {
          socket.join(`location-share:${targetUserId}`);
          socket.joinedRooms.add(`location-share:${targetUserId}`);
          
          socket.emit('location:sharing-joined', {
            success: true,
            sessionId,
            targetUserId
          });

          logger.info(`User ${socket.userId} joined location sharing for ${targetUserId}`);
        } else {
          socket.emit('location:sharing-error', {
            success: false,
            error: 'Invalid sharing session or no permission'
          });
        }
      } catch (error) {
        logger.error('Error joining location sharing:', error);
        socket.emit('location:sharing-error', {
          success: false,
          error: 'Failed to join location sharing'
        });
      }
    });
  }

  private setupGeofencingEvents(socket: AuthenticatedSocket): void {
    // Create geofence
    socket.on('geofence:create', async (geofenceData) => {
      try {
        const { name, geometry, type, triggers, metadata, description } = geofenceData;
        
        const result = await this.geofencingService.createGeofence(
          socket.userId!,
          name,
          geometry,
          type,
          triggers,
          metadata,
          description
        );

        if (result.success) {
          socket.emit('geofence:created', {
            success: true,
            geofenceId: result.geofenceId,
            geofence: result.geofence
          });

          // Join geofence room for updates
          socket.join(`geofence:${result.geofenceId}`);
          socket.joinedRooms.add(`geofence:${result.geofenceId}`);

          logger.info(`Geofence created by user ${socket.userId}: ${result.geofenceId}`);
        } else {
          socket.emit('geofence:create-error', {
            success: false,
            error: result.error || 'Failed to create geofence'
          });
        }
      } catch (error) {
        logger.error('Error creating geofence:', error);
        socket.emit('geofence:create-error', {
          success: false,
          error: 'Internal server error'
        });
      }
    });

    // Subscribe to geofence events
    socket.on('geofence:subscribe', async (data) => {
      try {
        const { geofenceIds } = data;
        
        if (Array.isArray(geofenceIds)) {
          geofenceIds.forEach(geofenceId => {
            socket.join(`geofence:${geofenceId}`);
            socket.joinedRooms.add(`geofence:${geofenceId}`);
          });

          socket.emit('geofence:subscribed', {
            success: true,
            geofenceIds
          });

          logger.info(`User ${socket.userId} subscribed to geofences: ${geofenceIds.join(', ')}`);
        }
      } catch (error) {
        logger.error('Error subscribing to geofences:', error);
        socket.emit('geofence:subscribe-error', {
          success: false,
          error: 'Failed to subscribe to geofences'
        });
      }
    });

    // Update geofence
    socket.on('geofence:update', async (data) => {
      try {
        const { geofenceId, updates } = data;
        
        const result = await this.geofencingService.updateGeofence(geofenceId, updates);

        if (result.success) {
          socket.emit('geofence:updated', {
            success: true,
            geofenceId
          });

          // Notify all subscribers
          this.io.to(`geofence:${geofenceId}`).emit('geofence:updated-notification', {
            geofenceId,
            updates,
            updatedBy: socket.userId
          });

          logger.info(`Geofence ${geofenceId} updated by user ${socket.userId}`);
        } else {
          socket.emit('geofence:update-error', {
            success: false,
            error: result.error || 'Failed to update geofence'
          });
        }
      } catch (error) {
        logger.error('Error updating geofence:', error);
        socket.emit('geofence:update-error', {
          success: false,
          error: 'Internal server error'
        });
      }
    });
  }

  private setupNavigationEvents(socket: AuthenticatedSocket): void {
    // Start navigation
    socket.on('navigation:start', async (data) => {
      try {
        const { routeId, currentLocation } = data;
        
        const result = await this.navigationService.startNavigation(
          socket.userId!,
          routeId,
          currentLocation
        );

        if (result.success) {
          // Store navigation session
          this.navigationSessions.set(result.sessionId!, {
            socket,
            sessionId: result.sessionId!
          });

          socket.emit('navigation:started', {
            success: true,
            sessionId: result.sessionId,
            route: result.route
          });

          logger.info(`Navigation started for user ${socket.userId}: ${result.sessionId}`);
        } else {
          socket.emit('navigation:start-error', {
            success: false,
            error: result.error || 'Failed to start navigation'
          });
        }
      } catch (error) {
        logger.error('Error starting navigation:', error);
        socket.emit('navigation:start-error', {
          success: false,
          error: 'Internal server error'
        });
      }
    });

    // Request reroute
    socket.on('navigation:reroute', async (data) => {
      try {
        const { sessionId, currentLocation, avoidAreas } = data;
        
        const result = await this.navigationService.rerouteNavigation(
          sessionId,
          currentLocation,
          avoidAreas
        );

        if (result.success) {
          socket.emit('navigation:rerouted', {
            success: true,
            newRoute: result.newRoute,
            sessionId
          });

          logger.info(`Navigation rerouted for session ${sessionId}`);
        } else {
          socket.emit('navigation:reroute-error', {
            success: false,
            error: result.error || 'Failed to reroute navigation'
          });
        }
      } catch (error) {
        logger.error('Error rerouting navigation:', error);
        socket.emit('navigation:reroute-error', {
          success: false,
          error: 'Internal server error'
        });
      }
    });

    // Stop navigation
    socket.on('navigation:stop', async (data) => {
      try {
        const { sessionId } = data;
        
        const result = await this.navigationService.stopNavigation(sessionId);

        if (result.success) {
          // Remove from active sessions
          this.navigationSessions.delete(sessionId);

          socket.emit('navigation:stopped', {
            success: true,
            sessionId
          });

          logger.info(`Navigation stopped for session ${sessionId}`);
        } else {
          socket.emit('navigation:stop-error', {
            success: false,
            error: result.error || 'Navigation session not found'
          });
        }
      } catch (error) {
        logger.error('Error stopping navigation:', error);
        socket.emit('navigation:stop-error', {
          success: false,
          error: 'Internal server error'
        });
      }
    });

    // Report traffic
    socket.on('navigation:report-traffic', async (data) => {
      try {
        const { location, radius, severity, type, description, estimatedEndTime } = data;
        
        const result = await this.navigationService.addTrafficUpdate(
          location,
          radius,
          severity,
          type,
          description,
          estimatedEndTime ? new Date(estimatedEndTime) : undefined
        );

        if (result.success) {
          socket.emit('navigation:traffic-reported', {
            success: true,
            updateId: result.updateId
          });

          // Broadcast to nearby users (within 10km)
          socket.broadcast.emit('navigation:traffic-update', {
            updateId: result.updateId,
            location,
            radius,
            severity,
            type,
            description,
            reportedBy: socket.username,
            timestamp: new Date()
          });

          logger.info(`Traffic update reported by user ${socket.userId}: ${result.updateId}`);
        } else {
          socket.emit('navigation:traffic-error', {
            success: false,
            error: result.error || 'Failed to report traffic'
          });
        }
      } catch (error) {
        logger.error('Error reporting traffic:', error);
        socket.emit('navigation:traffic-error', {
          success: false,
          error: 'Internal server error'
        });
      }
    });
  }

  private setupGeneralEvents(socket: AuthenticatedSocket): void {
    // Get nearby users
    socket.on('maps:get-nearby-users', async (data) => {
      try {
        const { latitude, longitude, radius = 1000 } = data;
        
        // Get users sharing location within radius
        const nearbyUsers: any[] = [];
        
        for (const [userId, userSocket] of this.connectedUsers.entries()) {
          if (userId !== socket.userId && socket.joinedRooms.has(`location-share:${userId}`)) {
            const userLocation = await this.locationTrackingService.getCurrentLocation(userId);
            
            if (userLocation) {
              // Calculate distance (simplified)
              const distance = this.calculateDistance(
                { latitude, longitude },
                { latitude: userLocation.latitude, longitude: userLocation.longitude }
              );
              
              if (distance <= radius) {
                nearbyUsers.push({
                  userId,
                  username: userSocket.username,
                  location: userLocation,
                  distance
                });
              }
            }
          }
        }

        socket.emit('maps:nearby-users', {
          success: true,
          users: nearbyUsers,
          count: nearbyUsers.length
        });
      } catch (error) {
        logger.error('Error getting nearby users:', error);
        socket.emit('maps:nearby-users-error', {
          success: false,
          error: 'Failed to get nearby users'
        });
      }
    });

    // Emergency broadcast
    socket.on('maps:emergency', async (data) => {
      try {
        const { location, message, type = 'general' } = data;
        
        const emergencyAlert = {
          userId: socket.userId,
          username: socket.username,
          location,
          message,
          type,
          timestamp: new Date()
        };

        // Broadcast to all nearby users (within 5km)
        this.io.emit('maps:emergency-alert', emergencyAlert);

        logger.warn(`Emergency alert from user ${socket.userId}: ${type} - ${message}`);
        
        socket.emit('maps:emergency-sent', {
          success: true,
          message: 'Emergency alert sent to nearby users'
        });
      } catch (error) {
        logger.error('Error broadcasting emergency:', error);
        socket.emit('maps:emergency-error', {
          success: false,
          error: 'Failed to send emergency alert'
        });
      }
    });
  }

  private handleDisconnection(socket: AuthenticatedSocket): void {
    logger.info(`🔌 User disconnected: ${socket.userId} (${socket.username})`);
    
    // Remove from connected users
    this.connectedUsers.delete(socket.userId!);
    
    // Clean up location tracking
    const trackingTimer = this.locationTrackers.get(socket.userId!);
    if (trackingTimer) {
      clearInterval(trackingTimer);
      this.locationTrackers.delete(socket.userId!);
    }
    
    // Clean up navigation sessions
    for (const [sessionId, session] of this.navigationSessions.entries()) {
      if (session.socket.userId === socket.userId) {
        this.navigationSessions.delete(sessionId);
        // Stop navigation session
        this.navigationService.stopNavigation(sessionId).catch(error => {
          logger.error(`Error stopping navigation session ${sessionId}:`, error);
        });
      }
    }
    
    // Stop location tracking
    this.locationTrackingService.stopLocationTracking(socket.userId!).catch(error => {
      logger.error(`Error stopping location tracking for ${socket.userId}:`, error);
    });
    
    // Leave all rooms
    socket.joinedRooms.forEach(room => {
      socket.leave(room);
    });
  }

  private calculateDistance(point1: { latitude: number; longitude: number }, point2: { latitude: number; longitude: number }): number {
    const R = 6371e3; // Earth's radius in meters
    const φ1 = point1.latitude * Math.PI / 180;
    const φ2 = point2.latitude * Math.PI / 180;
    const Δφ = (point2.latitude - point1.latitude) * Math.PI / 180;
    const Δλ = (point2.longitude - point1.longitude) * Math.PI / 180;

    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
  }

  public getConnectedUsers(): Map<string, AuthenticatedSocket> {
    return this.connectedUsers;
  }

  public getActiveNavigationSessions(): Map<string, { socket: AuthenticatedSocket, sessionId: string }> {
    return this.navigationSessions;
  }

  public broadcastToNearbyUsers(location: { latitude: number; longitude: number }, radius: number, event: string, data: any): void {
    this.connectedUsers.forEach(async (userSocket, userId) => {
      try {
        const userLocation = await this.locationTrackingService.getCurrentLocation(userId);
        
        if (userLocation) {
          const distance = this.calculateDistance(location, {
            latitude: userLocation.latitude,
            longitude: userLocation.longitude
          });
          
          if (distance <= radius) {
            userSocket.emit(event, data);
          }
        }
      } catch (error) {
        logger.error(`Error broadcasting to user ${userId}:`, error);
      }
    });
  }
}

export default AdvancedMapsSocketHandler;